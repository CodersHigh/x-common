## 1단계

"만약 시저가 비밀스럽게 할 말이 있었으면, 암호문으로 작성하곤 했다. 그 암호는 알파벳의 글자 순서를 바꾸는 것으로, 한 글자도 알아보지 못하게 하는 것이었다. 이 암호를 해독해 원래 의미를 해석하기 위해서는, 알파벳의 네 번째 글자인 D를 A와 바꾸고, 다른 글자들도 마찬가지로 바꾸면 되었다." —수에토니우스, 줄리어스 시저의 삶

암호는 쉽게 해독할 여지를 남기면서도, 글을 해석하지 못하게 하는 간단한 형식의 알고리즘입니다. 암호는 많은 형태의 암호분석에는 취약하기도 하지만, 우리 여동생들이 암호해독학을 공부한 것은 아닐테니까요.

시저 암호는 줄이어스 시저가 멀리 떨어진 곳에 메시지를 보낼 때 사용하곤 했던 방법입니다. 시저는 이 암호가 그리 좋은 편이 아님을 알고는 있었지만, 그럼에도 거의 누구도 읽기 힘들다는 것 또한 알고 있었습니다. 심지어 몇 글자만 바꾸는 것 만으로도 사람들은 이들이 알만한 단어 조차 알아보지 못했습니다. 

여기서 당신이 할 일은 이러한 시저 암호처럼 간단한 이동식 암호를 만들어내는 것입니다.

예를 들어:

함수에 "iamapandabear"를 입력하면 "ldpdsdqgdehdu"라는 암호문 결과를 출력합니다. 이정도면 전송 과정에서 메시지를 드러나지 않게 숨기기에 충분할 것입니다.

해독 함수에 "ldpdsdqgdehdu"를 입력하면 원래 단어인 "iamapandabear"을 출력해 원래 의미를 친구가 파악할 수 있습니다.

## 2단계

우리 조그만 여동생이 이동식암호를 이해하게 된다면, 더이상 그 암호는 의미가 없을 것입니다. 특정 key를 선정해 그것을 이동시킬 거리로 사용할 수 있도록 코드를 수정해보세요. 이러한 암호 방식을 치환암호라고 부릅니다.

여기 예시가 있습니다:

"aaaaaaaaaaaaaaaaaa"라는 key가 주어지면, "iamapandabear"라는 문자열을 암호화해도 기존의 "iamapandabear"를 결과로 냅니다.

"ddddddddddddddddd"라는 키가 주어지면, 문자열 "iamapandabear"는 "lpdsdqgdehdu"라는 알 수 없는 단어로 변환됩니다.

첫 번째 예시에서는, key 값으로 a = 0을 설정한 것입니다. 그래서 평문(암호문의 원문)이 key에 더해지더라도 같은 메시지가 결과로 나온 것입니다. 그래서 "aaaa"는 이상적인 key라고는 볼 수 없겠죠. 하지만 key를 "dddd"라고 설정한다면, 우리는 시저 암호에서와 같은 결과를 얻을 수 있을 것입니다.

## 3단계

어떤 암호에서든 가장 큰 약점은 바로 사람입니다. 임의성을 추가하고 key가 숫자나 대문자로 이루어지지 않도록 해서 앞에서 만든 치환암호의 결함을 보완하세요. 
앞에서 만든 치환암호에 

key를 굳이 입력하지 않은 경우에도, Cipher#key로 접근 가능한 100개 이상의 문자로 이루어진 임의의 key를 생성해주세요. (#은 인스턴스 변수를 의미)

입력한 key가 숫자나 대문자를 포함하고 있으면, ArgumentError를 메시지와 함께 보이세요.

## 추가

이동식 암호는 기존 텍스트를 읽지 못하게 만드는 방식으로 작동하지만, 빈도수 분석에 취약하다는 단점이 있습니다. 치환암호는 그러한 면을 보완하지만, 여전히 공간이 할당되거나 key가 짧은 형태일 때 취약성을 드러냅니다. 이러한 문제에 대한 방안으로 "crypto-square"가 있습니다.

이 주제에 대해 더 알아보고 싶다면, 맨 처음 시작할 질문은 어떻게 key를 보안된 상태에서 변환할 것인가입니다. 위키피디아에서 이러한 고민의 첫  완성을 이룬 [Diffie-Hellman][dh]을 찾아 읽어보세요.

[dh]: http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange
